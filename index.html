<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Hograders Space Game</title>
<style>
  body { margin: 0; overflow: hidden; font-family: sans-serif; }
  canvas { display: block; background: black; }
  #overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
    font-size: 2em; color: white; background: rgba(0,0,0,0.5);
    z-index: 10;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="600"></canvas>
<div id="overlay">Press Enter to Start</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');

let gameRunning = false;
let gamePaused = false;
let score = 0;
let highScore = localStorage.getItem('highScore') || 0;

let backgroundOffset = 0;

// Load assets (use free assets or your own)
const assets = {};

// Using placeholder colored rectangles for ships and effects
// For actual game, replace with sprite images fetched from URLs

// Create simple colored rectangles as sprite placeholders
function createPlaceholder(color, width, height) {
  const offCanvas = document.createElement('canvas');
  offCanvas.width = width;
  offCanvas.height = height;
  const ctx = offCanvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, width, height);
  return offCanvas;
}

// Sprites
assets.player = createPlaceholder('cyan', 40, 20);
assets.enemy1 = createPlaceholder('red', 30, 20);
assets.enemy2 = createPlaceholder('orange', 35, 25);
assets.boss = createPlaceholder('purple', 150, 60);
assets.powerUp = createPlaceholder('green', 20, 20);
assets.rocket = createPlaceholder('gold', 50, 150);
assets.background = createPlaceholder('black', 800, 600);

// Particle effect for explosions
const explosionSprites = [];
for (let i=0; i<16; i++) {
  const c = createPlaceholder(`hsl(${Math.random()*360}, 100%, 50%)`, 20, 20);
  explosionSprites.push(c);
}

// Game entities
const player = {
  x: 100,
  y: 300,
  width: 40,
  height: 20,
  speed: 5,
  movingUp: false,
  movingDown: false,
  shootCooldown: 0,
};

const bullets = [];
const enemies = [];
const particles = []; // explosion particles
const powerUps = [];
let boss = null;
let bossWave = false;
let bossHealth = 50;

const keys = {};

let gameTime = 0;

// Event listeners
document.addEventListener('keydown', (e) => {
  keys[e.key] = true;
  if (e.key === 'Enter' && !gameRunning) {
    startGame();
  }
  if (e.key === 'Escape') {
    togglePause();
  }
});
document.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// Start game
function startGame() {
  overlay.style.display = 'none';
  gameRunning = true;
  score = 0;
  backgroundOffset = 0;
  enemies.length=0;
  bullets.length=0;
  particles.length=0;
  powerUps.length=0;
  boss = null;
  bossWave = false;
  gameTime = 0;
  requestAnimationFrame(loop);
}

function togglePause() {
  gamePaused = !gamePaused;
  if (gamePaused) {
    overlay.innerHTML = 'Paused<br>Press Escape to Resume';
    overlay.style.display = 'flex';
  } else {
    overlay.style.display = 'none';
    requestAnimationFrame(loop);
  }
}

// Main game loop
function loop() {
  if (!gameRunning || gamePaused) return;
  update();
  draw();
  requestAnimationFrame(loop);
}

// Update game state
function update() {
  gameTime++;
  // Background scroll
  backgroundOffset += 2;
  if (backgroundOffset >= assets.background.width) {
    backgroundOffset = 0;
  }

  // Player controls
  if (keys['ArrowUp']) player.y -= player.speed;
  if (keys['ArrowDown']) player.y += player.speed;
  if (keys[' '] && player.shootCooldown <= 0) {
    bullets.push({x: player.x + player.width, y: player.y + player.height/2, speed: 10});
    player.shootCooldown = 15;
  }
  if (player.shootCooldown > 0) player.shootCooldown--;

  // Keep player in bounds
  if (player.y < 0) player.y=0;
  if (player.y + player.height > 600) player.y=600 - player.height;

  // Spawn enemies
  if (gameTime % 60 === 0) spawnEnemy();

  // Spawn power-ups
  if (gameTime % 300 === 0) {
    powerUps.push({x: 800, y: Math.random() * (600-20), width:20, height:20, speed:3});
  }

  // Update bullets
  for (let i=bullets.length-1; i>=0; i--) {
    bullets[i].x += bullets[i].speed;
    if (bullets[i].x > 800) bullets.splice(i,1);
  }

  // Update enemies
  for (let i=enemies.length-1; i>=0; i--) {
    enemies[i].x -= enemies[i].speed;
    if (enemies[i].x + enemies[i].width < 0) enemies.splice(i,1);
    // Check collision with bullets
    for (let j=bullets.length-1; j>=0; j--) {
      if (isColliding(enemies[i], bullets[j])) {
        spawnExplosion(enemies[i].x, enemies[i].y);
        enemies.splice(i,1);
        bullets.splice(j,1);
        score += 10;
        break;
      }
    }
  }

  // Power-ups
  for (let i=powerUps.length-1; i>=0; i--) {
    powerUps[i].x -= powerUps[i].speed;
    if (powerUps[i].x + powerUps[i].width < 0) powerUps.splice(i,1);
    if (isColliding(player, powerUps[i])) {
      score += 50;
      powerUps.splice(i,1);
      // You can add effects here
    }
  }

  // Boss wave
  if (boss && bossHealth > 0) {
    boss.x -= boss.speed;
    // Check collision with player
    if (isColliding(player, boss)) {
      spawnExplosion(player.x+player.width/2, player.y+player.height/2);
      // Implement damage or game over logic
    }
    // Bullets hit boss
    for (let j=bullets.length-1; j>=0; j--) {
      if (isColliding(boss, bullets[j])) {
        spawnExplosion(boss.x+boss.width/2, boss.y+boss.height/2);
        bossHealth--;
        bullets.splice(j,1);
        if (bossHealth <=0) {
          spawnExplosion(boss.x, boss.y);
          boss = null;
          score += 200;
        }
      }
    }
  } else {
    if (score >= 1200 && !bossWave) spawnBoss();
    // Rocket ending at 2000
    if (score >= 2000) triggerRocket();
  }
}

// Draw everything
function draw() {
  ctx.clearRect(0,0,800,600);
  // Draw background
  ctx.drawImage(assets.background, backgroundOffset, 0);
  ctx.drawImage(assets.background, backgroundOffset - assets.background.width, 0);

  // Draw player
  ctx.drawImage(assets.player, player.x, player.y);

  // Draw bullets
  ctx.fillStyle='yellow';
  for (const b of bullets) {
    ctx.fillRect(b.x, b.y, 10, 3);
  }

  // Draw enemies
  for (const e of enemies) {
    ctx.drawImage(assets.enemy1, e.x, e.y);
  }

  // Draw power-ups
  for (const p of powerUps) {
    ctx.fillStyle='lime';
    ctx.fillRect(p.x, p.y, p.width, p.height);
  }

  // Draw boss
  if (boss) {
    ctx.drawImage(assets.boss, boss.x, boss.y);
    // Draw boss health bar
    ctx.fillStyle='red';
    ctx.fillRect(boss.x, boss.y - 10, boss.width*(bossHealth/50), 5);
  }

  // Draw particles (explosions)
  for (const p of particles) {
    ctx.globalAlpha=p.alpha;
    ctx.drawImage(p.sprite, p.x, p.y);
    ctx.globalAlpha=1;
  }

  // HUD
  ctx.fillStyle='white';
  ctx.font='20px Arial';
  ctx.fillText(`Score: ${score}`, 10, 20);
  ctx.fillText(`High Score: ${highScore}`, 10, 45);
}

// Helper functions
function spawnEnemy() {
  const type = Math.random()<0.5?'enemy1':'enemy2';
  const y=Math.random()*(600-30);
  const sprite=type==='enemy1'?assets.enemy1:assets.enemy2;
  enemies.push({x:800, y, width: sprite.width, height: sprite.height, speed:3, sprite});
}

function spawnBoss() {
  boss = {x:800, y: (600 - 60)/2, width: assets.boss.width, height:assets.boss.height, speed:1};
  bossHealth=50;
  bossWave=true;
}

function spawnExplosion(x,y) {
  // create particles for explosion
  for (let i=0; i<8; i++) {
    particles.push({
      x, y,
      sprite: explosionSprites[Math.floor(Math.random()*explosionSprites.length)],
      vx: (Math.random()-0.5)*4,
      vy: (Math.random()-0.5)*4,
      alpha: 1,
      life: 30 + Math.random()*20,
    });
  }
}

function triggerRocket() {
  alert('Rocket Launch! Thanks for playing!');
  // Show rocket animation or cinematic here
  gameRunning=false;
  overlay.innerHTML='Game Over! Press Enter to Restart';
  overlay.style.display='flex';
  if (score > highScore) {
    localStorage.setItem('highScore', score);
    highScore=score;
  }
}

// Collision detection
function isColliding(a, b) {
  return a.x<a.x+b.width && a.x+a.width>b.x && a.y<b.y+b.height && a.y+a.height>b.y;
}

// Handle particles updates
function updateParticles() {
  for (let i=particles.length-1; i>=0; i--) {
    const p=particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    p.alpha = p.life/50;
    if (p.life<=0) particles.splice(i,1);
  }
}

// Main loop
function gameLoop() {
  if (!gameRunning || gamePaused) return;
  update();
  updateParticles();
  draw();
  requestAnimationFrame(gameLoop);
}

// Start initial loop
window.onload = () => {
  startGame();
};
</script>
</body>
</html>
